#### 什么是闭包？

- 有权访问另一个函数作用域中的变量的函数 （一般情况下就是一个函数里面还有一个子函数）

  - 闭包是一个函数 存在与另一个函数当中

  - 闭包这个函数可以访问到父级函数的变量，且该变量不会被销毁

  - ```js
    function person(){
        var name = '有鱼';
        function cat(){
            console.log(name);
        }
        return cat;
    }
    var per = person();// per的值就是return后的结果，即cat函数
    per();// 有鱼 per()就相当于cat()
    per();// 有鱼 同上，而且变量name没有销毁，一直存在内存中，供函数cat调用
    per();// 有鱼
    ```

    

#### 闭包的实现原理 就是利用==作用域链==的特性 

- 当前环境下访问某个变量时 如果不存在就一直向外寻找 最终找到最外层就是全局作用域 这样就形成一个链条

- ```js
  //定义一个变量的时候如果希望它每次都会随着增加需要定义成全局变量  但是这样的话 会污染全局 容易被修改 不安全
  function father(){
  var age=18;
  function child(){
  age++;
  console.log(age)
  }
  return child;
  }
  
  var f=father()
  f()//19
  f()//20
  //这样闭包就可以很好的解决这个问题
  ```

- JS规定在一个函数作用域内，程序执行完成以后变量就会销毁这样来节省内存

- 按照作用域链的特点 闭包函数外部的变量是不会被销毁的，因为父函数的调用一直存在  闭包过多会造成内存泄漏

#### 闭包的作用

- 优点

  - 隐藏变量 避免全局污染

  - 可以读取到函数内部的变量


- 缺点

  - 子函数里面会一直存在对父亲函数变量的引用 导致变量不会被垃圾回收机制回收 造成内存消耗问题

  - 不恰当的使用闭包会造成内存泄漏的问题

  - 闭包会在父函数外部 改变父函数内部的值 所以 如果你把父函数当作对象使用，把闭包当作它的公共方法，把内部变量当作私有属性，不要随便改变父函数内部变量的值

    

    



#### 闭包的应用

- setTimeout传参 

- ```js
  //原生的setTimeout传递的第一个函数不能带参数
  setTimeout(function(param){
      alert(param)
  },1000)
  
  
  //通过闭包可以实现传参效果
  function func(param){
      return function(){
          alert(param)
      }
  }
  var f1 = func(1);
  setTimeout(f1,1000);
  ```

- //我们定义行为，然后把它关联到某个用户事件上（点击或者按键）。我们的代码通常会作为一个回调（事件触发时调用的函数）绑定到事件上

- 封装变量   用闭包定义能访问私有函数和私有变量的公用函数

- ==为节点循环绑定点击事件==   //这个很重要  一般的方法只会对最后一个值做修改  因为回调触发的时候  循环已经执行结束  变量已经变为最后一次循环的变量

  - 闭包可以解决这个问题  为每一个回调都创建一个新的词法环境
  - 循环的事件放在立即执行函数当中 用当前循环的值绑定再函数上  不是循环结束的值
  - 用es6声明避免声明提前 作用域只在当前作用块当中

- 循环调用一个异步方法

